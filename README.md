
# 设计模式是什么？
    设计模式是软件设计中常见问题的典型解决方案。 它们就像能根据需求进行调整的预制蓝图， 可用于解决代码中反复出现的设计问题。
    设计模式与方法或库的使用方式不同， 你很难直接在自己的程序中套用某个设计模式。 模式并不是一段特定的代码， 而是解决特定问题的一般性概念。 你可以根据模式来实现符合自己程序实际所需的解决方案。

# 模式包含哪些内容？
    大部分模式都有正规的描述方式， 以便在不同情况下使用。 模式的描述通常会包括以下部分：
* ***意图***部分简单描述问题和解决方案
* ***动机***部分将进一步解释问题并说明模式会如何提供解决方案
* ***结构***部分展示模式的每个部分和它们之间的关系
* ***在不同语言中的实现***提供流行编程语言的代码， 让读者更好地理解模式背后的思想

# 设计模式分类
    不同设计模式的复杂程度、 细节层次以及在整个系统中的应用范围等方面各不相同。
    最基础的、 底层的模式通常被称为惯用技巧。
    最通用的、 高层的模式是构架模式。例如MVP，MVC，MVVM等。
    
# 所有模式可以根据其意图或目的来分类
* ***创建型模式***提供创建对象的机制， 增加已有代码的灵活性和可复用性。
* ***结构型模式***介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。
* ***行为模式***负责对象间的高效沟通和职责委派。

- 创建型模式
    这类模式提供创建对象的机制， 能够提升已有代码的灵活性和可复用性。
    
    - 工厂方法模式
    ```
        1 工厂方法模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。
        2 工厂方法模式结构
            2.1 产品 （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。
            2.2 具体产品 （Concrete Products） 是产品接口的不同实现。
            2.3 创建者 （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。
            2.4 具体创建者 （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。
    ```
    
    - 抽象工厂模式
    ```
        1 抽象工厂模式是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。
        2 抽象工厂模式结构
            2.1 抽象产品 （Abstract Product） 为构成系列产品的一组不同但相关的产品声明接口。
            2.2 具体产品 （Concrete Product） 是抽象产品的多种不同类型实现。
            2.3 抽象工厂 （Abstract Factory） 接口声明了一组创建各种抽象产品的方法。
            2.4 具体工厂 （Concrete Factory） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。
            2.5 尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的抽象产品。 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 客户端 （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/产品变体交互。
    ```
    
    - 生成器模式
    ```
        1 生成器模式是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。
        2 生成器模式结构
            2.1 生成器 （Builder） 接口声明在所有类型生成器中通用的产品构造步骤。
            2.2 具体生成器 （Concrete Builders） 提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。
            2.3 产品 （Products） 是最终生成的对象。 由不同生成器构造的产品无需属于同一类层次结构或接口。
            2.4 主管 （Director） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。
            2.5 客户端 （Client） 必须将某个生成器对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用生成器对象完成后续所有的构造任务。 但在客户端将生成器对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的生成器。
    ```
    
    - 原型模式
    ```
        1 原型模式是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。
        2 原型模式结构
            2.1 原型 （Prototype） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 clone克隆的方法。
            2.2 具体原型 （Concrete Prototype） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。
            2.3 客户端 （Client） 可以复制实现了原型接口的任何对象。
    ```
    
    - 单例模式
    ```
        1 单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。
        2 单例模式结构
            2.1 单例 （Singleton） 类声明了一个名为 get­Instance获取实例的静态方法来返回其所属类的一个相同实例。单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 获取实例方法必须是获取单例对象的唯一方式。
    ```
    
- 结构型模式
    这类模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。
    - 适配器模式
    - 桥接模式
    - 组合模式
    - 装饰模式
    - 外观模式
    - 享元模式
    - 代理模式
- 行为模式
    这类模式负责对象间的高效沟通和职责委派。
    - 责任链模式   
    - 命令模式
    - 迭代器模式
    - 中介者模式
    - 备忘录模式
    - 观察者模式
    - 状态模式
    - 策略模式
    - 模板方法模式
    - 访问者模式
